//============================================================================
//  Copyright (c) Kitware, Inc.
//  All rights reserved.
//  See LICENSE.txt for details.
//  This software is distributed WITHOUT ANY WARRANTY; without even
//  the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
//  PURPOSE.  See the above copyright notice for more information.
//
//  Copyright 2014 Sandia Corporation.
//  Copyright 2014 UT-Battelle, LLC.
//  Copyright 2014 Los Alamos National Security.
//
//  Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
//  the U.S. Government retains certain rights in this software.
//
//  Under the terms of Contract DE-AC52-06NA25396 with Los Alamos National
//  Laboratory (LANL), the U.S. Government retains certain rights in
//  this software.
//============================================================================
// **** DO NOT EDIT THIS FILE!!! ****
// This file is automatically generated by WorkletInvokeFunctorDetail.h.in

// Technically speaking, we can implement this functionality with some clever
// use of FunctionInterface rather than using pyexpander to make variadic
// code. However, this code is probably more friendly to compilers. I expect
// it to compiler faster and optimize better.

#ifndef vtk_m_exec_internal_WorkletInvokeFunctorDetail_h
#define vtk_m_exec_internal_WorkletInvokeFunctorDetail_h

#if !defined(vtk_m_exec_internal_WorkletInvokeFunctor_h) && !defined(VTKM_TEST_HEADER_BUILD)
#error WorkletInvokeFunctorDetail.h must be included from WorkletInvokeFunctor.h
#endif

#include <vtkm/internal/FunctionInterface.h>
#include <vtkm/internal/Invocation.h>

#include <vtkm/exec/arg/Fetch.h>

#if VTKM_MAX_FUNCTION_PARAMETERS != 10
#error Mismatch of maximum parameters between FunctionInterfaceDatailPre.h.in and WorkletInvokeFunctorDetail.h.in
#endif


namespace vtkm {
namespace exec {
namespace internal {
namespace detail {

/// A helper class that takes an \c Invocation object and an index to a
/// parameter in the ExecutionSignature and finds the \c Fetch type valid for
/// that parameter.
template<typename ThreadIndicesType,
         typename Invocation,
         vtkm::IdComponent ExecutionParameterIndex>
struct InvocationToFetch
{
  typedef typename Invocation::ExecutionInterface::
      template ParameterType<ExecutionParameterIndex>::type
        ExecutionSignatureTag;

  // Expected fields from ExecutionSignatureTag. If these do not exist in
  // ExecutionSignatureTag, then something that is not really an execution
  // signature tag was used in an ExecutionSignature.
  static const vtkm::IdComponent ControlParameterIndex =
      ExecutionSignatureTag::INDEX;
  typedef typename ExecutionSignatureTag::AspectTag AspectTag;

  // Find the fetch tag from the control signature tag pointed to by
  // ParameterIndex.
  typedef typename Invocation::ControlInterface ControlInterface;
  typedef typename ControlInterface::
      template ParameterType<ControlParameterIndex>::type ControlSignatureTag;
  typedef typename ControlSignatureTag::FetchTag FetchTag;

  typedef typename Invocation::ParameterInterface::
      template ParameterType<ControlParameterIndex>::type ExecObjectType;

  typedef vtkm::exec::arg::Fetch<
      FetchTag,AspectTag,ThreadIndicesType,ExecObjectType> type;
};

template<typename WorkletType,
         typename ParameterInterface,
         typename ControlInterface,
         vtkm::IdComponent InputDomainIndex,
         typename OutputToInputMapType,
         typename VisitArrayType,
         typename ThreadIndicesType,
         typename R,
         typename P1>
VTKM_EXEC_EXPORT
void DoWorkletInvokeFunctor(
      const WorkletType &worklet,
      const vtkm::internal::Invocation<
        ParameterInterface,
        ControlInterface,
        vtkm::internal::FunctionInterface<R(P1)>,
        InputDomainIndex,
        OutputToInputMapType,
        VisitArrayType> &invocation,
      const ThreadIndicesType &threadIndices)
{
  typedef vtkm::internal::Invocation<
      ParameterInterface,
      ControlInterface,
      vtkm::internal::FunctionInterface<R(P1)>,
      InputDomainIndex,
      OutputToInputMapType,
      VisitArrayType> Invocation;

  typedef InvocationToFetch<ThreadIndicesType,Invocation,1> FetchInfo1;
  typedef typename FetchInfo1::type FetchType1;
  FetchType1 fetch1;
  typename FetchType1::ValueType p1 =
      fetch1.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,0> FetchInfo0;
  typedef typename FetchInfo0::type ReturnFetchType;
  typedef typename ReturnFetchType::ValueType ReturnValueType;
  ReturnFetchType returnFetch;
  // If you got a compile error on the following line, it probably means that
  // the operator() of a worklet does not match the definition expected. One
  // common problem is that the operator() method must be declared const. Check
  // to make sure the "const" keyword is after parameters. Another common
  // problem is that the type of one or more parameters is incompatible with
  // the actual type that VTK-m creates in the execution environment. Make sure
  // that the types of the worklet operator() parameters match those in the
  // ExecutionSignature. The compiler error might help you narrow down which
  // parameter is wrong and the types that did not match.
  ReturnValueType r = ReturnValueType(worklet(p1));

  returnFetch.Store(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo0::ControlParameterIndex>(), r);

  fetch1.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>(), p1);
}

template<typename WorkletType,
         typename ParameterInterface,
         typename ControlInterface,
         vtkm::IdComponent InputDomainIndex,
         typename OutputToInputMapType,
         typename VisitArrayType,
         typename ThreadIndicesType,
         typename P1>
VTKM_EXEC_EXPORT
void DoWorkletInvokeFunctor(
      const WorkletType &worklet,
      const vtkm::internal::Invocation<
        ParameterInterface,
        ControlInterface,
        vtkm::internal::FunctionInterface<void(P1)>,
        InputDomainIndex,
        OutputToInputMapType,
        VisitArrayType> &invocation,
      const ThreadIndicesType &threadIndices)
{
  typedef vtkm::internal::Invocation<
      ParameterInterface,
      ControlInterface,
      vtkm::internal::FunctionInterface<void(P1)>,
      InputDomainIndex,
      OutputToInputMapType,
      VisitArrayType> Invocation;

  typedef InvocationToFetch<ThreadIndicesType,Invocation,1> FetchInfo1;
  typedef typename FetchInfo1::type FetchType1;
  FetchType1 fetch1;
  typename FetchType1::ValueType p1 =
      fetch1.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>());

  // If you got a compile error on the following line, it probably means that
  // the operator() of a worklet does not match the definition expected. One
  // common problem is that the operator() method must be declared const. Check
  // to make sure the "const" keyword is after parameters. Another common
  // problem is that the type of one or more parameters is incompatible with
  // the actual type that VTK-m creates in the execution environment. Make sure
  // that the types of the worklet operator() parameters match those in the
  // ExecutionSignature. The compiler error might help you narrow down which
  // parameter is wrong and the types that did not match.
  worklet(p1);

  fetch1.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>(), p1);
}

template<typename WorkletType,
         typename ParameterInterface,
         typename ControlInterface,
         vtkm::IdComponent InputDomainIndex,
         typename OutputToInputMapType,
         typename VisitArrayType,
         typename ThreadIndicesType,
         typename R,
         typename P1,
         typename P2>
VTKM_EXEC_EXPORT
void DoWorkletInvokeFunctor(
      const WorkletType &worklet,
      const vtkm::internal::Invocation<
        ParameterInterface,
        ControlInterface,
        vtkm::internal::FunctionInterface<R(P1,P2)>,
        InputDomainIndex,
        OutputToInputMapType,
        VisitArrayType> &invocation,
      const ThreadIndicesType &threadIndices)
{
  typedef vtkm::internal::Invocation<
      ParameterInterface,
      ControlInterface,
      vtkm::internal::FunctionInterface<R(P1,P2)>,
      InputDomainIndex,
      OutputToInputMapType,
      VisitArrayType> Invocation;

  typedef InvocationToFetch<ThreadIndicesType,Invocation,1> FetchInfo1;
  typedef typename FetchInfo1::type FetchType1;
  FetchType1 fetch1;
  typename FetchType1::ValueType p1 =
      fetch1.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,2> FetchInfo2;
  typedef typename FetchInfo2::type FetchType2;
  FetchType2 fetch2;
  typename FetchType2::ValueType p2 =
      fetch2.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo2::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,0> FetchInfo0;
  typedef typename FetchInfo0::type ReturnFetchType;
  typedef typename ReturnFetchType::ValueType ReturnValueType;
  ReturnFetchType returnFetch;
  // If you got a compile error on the following line, it probably means that
  // the operator() of a worklet does not match the definition expected. One
  // common problem is that the operator() method must be declared const. Check
  // to make sure the "const" keyword is after parameters. Another common
  // problem is that the type of one or more parameters is incompatible with
  // the actual type that VTK-m creates in the execution environment. Make sure
  // that the types of the worklet operator() parameters match those in the
  // ExecutionSignature. The compiler error might help you narrow down which
  // parameter is wrong and the types that did not match.
  ReturnValueType r = ReturnValueType(worklet(p1,p2));

  returnFetch.Store(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo0::ControlParameterIndex>(), r);

  fetch1.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>(), p1);
  fetch2.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo2::ControlParameterIndex>(), p2);
}

template<typename WorkletType,
         typename ParameterInterface,
         typename ControlInterface,
         vtkm::IdComponent InputDomainIndex,
         typename OutputToInputMapType,
         typename VisitArrayType,
         typename ThreadIndicesType,
         typename P1,
         typename P2>
VTKM_EXEC_EXPORT
void DoWorkletInvokeFunctor(
      const WorkletType &worklet,
      const vtkm::internal::Invocation<
        ParameterInterface,
        ControlInterface,
        vtkm::internal::FunctionInterface<void(P1,P2)>,
        InputDomainIndex,
        OutputToInputMapType,
        VisitArrayType> &invocation,
      const ThreadIndicesType &threadIndices)
{
  typedef vtkm::internal::Invocation<
      ParameterInterface,
      ControlInterface,
      vtkm::internal::FunctionInterface<void(P1,P2)>,
      InputDomainIndex,
      OutputToInputMapType,
      VisitArrayType> Invocation;

  typedef InvocationToFetch<ThreadIndicesType,Invocation,1> FetchInfo1;
  typedef typename FetchInfo1::type FetchType1;
  FetchType1 fetch1;
  typename FetchType1::ValueType p1 =
      fetch1.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,2> FetchInfo2;
  typedef typename FetchInfo2::type FetchType2;
  FetchType2 fetch2;
  typename FetchType2::ValueType p2 =
      fetch2.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo2::ControlParameterIndex>());

  // If you got a compile error on the following line, it probably means that
  // the operator() of a worklet does not match the definition expected. One
  // common problem is that the operator() method must be declared const. Check
  // to make sure the "const" keyword is after parameters. Another common
  // problem is that the type of one or more parameters is incompatible with
  // the actual type that VTK-m creates in the execution environment. Make sure
  // that the types of the worklet operator() parameters match those in the
  // ExecutionSignature. The compiler error might help you narrow down which
  // parameter is wrong and the types that did not match.
  worklet(p1,p2);

  fetch1.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>(), p1);
  fetch2.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo2::ControlParameterIndex>(), p2);
}

template<typename WorkletType,
         typename ParameterInterface,
         typename ControlInterface,
         vtkm::IdComponent InputDomainIndex,
         typename OutputToInputMapType,
         typename VisitArrayType,
         typename ThreadIndicesType,
         typename R,
         typename P1,
         typename P2,
         typename P3>
VTKM_EXEC_EXPORT
void DoWorkletInvokeFunctor(
      const WorkletType &worklet,
      const vtkm::internal::Invocation<
        ParameterInterface,
        ControlInterface,
        vtkm::internal::FunctionInterface<R(P1,P2,P3)>,
        InputDomainIndex,
        OutputToInputMapType,
        VisitArrayType> &invocation,
      const ThreadIndicesType &threadIndices)
{
  typedef vtkm::internal::Invocation<
      ParameterInterface,
      ControlInterface,
      vtkm::internal::FunctionInterface<R(P1,P2,P3)>,
      InputDomainIndex,
      OutputToInputMapType,
      VisitArrayType> Invocation;

  typedef InvocationToFetch<ThreadIndicesType,Invocation,1> FetchInfo1;
  typedef typename FetchInfo1::type FetchType1;
  FetchType1 fetch1;
  typename FetchType1::ValueType p1 =
      fetch1.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,2> FetchInfo2;
  typedef typename FetchInfo2::type FetchType2;
  FetchType2 fetch2;
  typename FetchType2::ValueType p2 =
      fetch2.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo2::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,3> FetchInfo3;
  typedef typename FetchInfo3::type FetchType3;
  FetchType3 fetch3;
  typename FetchType3::ValueType p3 =
      fetch3.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo3::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,0> FetchInfo0;
  typedef typename FetchInfo0::type ReturnFetchType;
  typedef typename ReturnFetchType::ValueType ReturnValueType;
  ReturnFetchType returnFetch;
  // If you got a compile error on the following line, it probably means that
  // the operator() of a worklet does not match the definition expected. One
  // common problem is that the operator() method must be declared const. Check
  // to make sure the "const" keyword is after parameters. Another common
  // problem is that the type of one or more parameters is incompatible with
  // the actual type that VTK-m creates in the execution environment. Make sure
  // that the types of the worklet operator() parameters match those in the
  // ExecutionSignature. The compiler error might help you narrow down which
  // parameter is wrong and the types that did not match.
  ReturnValueType r = ReturnValueType(worklet(p1,p2,p3));

  returnFetch.Store(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo0::ControlParameterIndex>(), r);

  fetch1.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>(), p1);
  fetch2.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo2::ControlParameterIndex>(), p2);
  fetch3.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo3::ControlParameterIndex>(), p3);
}

template<typename WorkletType,
         typename ParameterInterface,
         typename ControlInterface,
         vtkm::IdComponent InputDomainIndex,
         typename OutputToInputMapType,
         typename VisitArrayType,
         typename ThreadIndicesType,
         typename P1,
         typename P2,
         typename P3>
VTKM_EXEC_EXPORT
void DoWorkletInvokeFunctor(
      const WorkletType &worklet,
      const vtkm::internal::Invocation<
        ParameterInterface,
        ControlInterface,
        vtkm::internal::FunctionInterface<void(P1,P2,P3)>,
        InputDomainIndex,
        OutputToInputMapType,
        VisitArrayType> &invocation,
      const ThreadIndicesType &threadIndices)
{
  typedef vtkm::internal::Invocation<
      ParameterInterface,
      ControlInterface,
      vtkm::internal::FunctionInterface<void(P1,P2,P3)>,
      InputDomainIndex,
      OutputToInputMapType,
      VisitArrayType> Invocation;

  typedef InvocationToFetch<ThreadIndicesType,Invocation,1> FetchInfo1;
  typedef typename FetchInfo1::type FetchType1;
  FetchType1 fetch1;
  typename FetchType1::ValueType p1 =
      fetch1.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,2> FetchInfo2;
  typedef typename FetchInfo2::type FetchType2;
  FetchType2 fetch2;
  typename FetchType2::ValueType p2 =
      fetch2.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo2::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,3> FetchInfo3;
  typedef typename FetchInfo3::type FetchType3;
  FetchType3 fetch3;
  typename FetchType3::ValueType p3 =
      fetch3.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo3::ControlParameterIndex>());

  // If you got a compile error on the following line, it probably means that
  // the operator() of a worklet does not match the definition expected. One
  // common problem is that the operator() method must be declared const. Check
  // to make sure the "const" keyword is after parameters. Another common
  // problem is that the type of one or more parameters is incompatible with
  // the actual type that VTK-m creates in the execution environment. Make sure
  // that the types of the worklet operator() parameters match those in the
  // ExecutionSignature. The compiler error might help you narrow down which
  // parameter is wrong and the types that did not match.
  worklet(p1,p2,p3);

  fetch1.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>(), p1);
  fetch2.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo2::ControlParameterIndex>(), p2);
  fetch3.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo3::ControlParameterIndex>(), p3);
}

template<typename WorkletType,
         typename ParameterInterface,
         typename ControlInterface,
         vtkm::IdComponent InputDomainIndex,
         typename OutputToInputMapType,
         typename VisitArrayType,
         typename ThreadIndicesType,
         typename R,
         typename P1,
         typename P2,
         typename P3,
         typename P4>
VTKM_EXEC_EXPORT
void DoWorkletInvokeFunctor(
      const WorkletType &worklet,
      const vtkm::internal::Invocation<
        ParameterInterface,
        ControlInterface,
        vtkm::internal::FunctionInterface<R(P1,P2,P3,P4)>,
        InputDomainIndex,
        OutputToInputMapType,
        VisitArrayType> &invocation,
      const ThreadIndicesType &threadIndices)
{
  typedef vtkm::internal::Invocation<
      ParameterInterface,
      ControlInterface,
      vtkm::internal::FunctionInterface<R(P1,P2,P3,P4)>,
      InputDomainIndex,
      OutputToInputMapType,
      VisitArrayType> Invocation;

  typedef InvocationToFetch<ThreadIndicesType,Invocation,1> FetchInfo1;
  typedef typename FetchInfo1::type FetchType1;
  FetchType1 fetch1;
  typename FetchType1::ValueType p1 =
      fetch1.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,2> FetchInfo2;
  typedef typename FetchInfo2::type FetchType2;
  FetchType2 fetch2;
  typename FetchType2::ValueType p2 =
      fetch2.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo2::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,3> FetchInfo3;
  typedef typename FetchInfo3::type FetchType3;
  FetchType3 fetch3;
  typename FetchType3::ValueType p3 =
      fetch3.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo3::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,4> FetchInfo4;
  typedef typename FetchInfo4::type FetchType4;
  FetchType4 fetch4;
  typename FetchType4::ValueType p4 =
      fetch4.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo4::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,0> FetchInfo0;
  typedef typename FetchInfo0::type ReturnFetchType;
  typedef typename ReturnFetchType::ValueType ReturnValueType;
  ReturnFetchType returnFetch;
  // If you got a compile error on the following line, it probably means that
  // the operator() of a worklet does not match the definition expected. One
  // common problem is that the operator() method must be declared const. Check
  // to make sure the "const" keyword is after parameters. Another common
  // problem is that the type of one or more parameters is incompatible with
  // the actual type that VTK-m creates in the execution environment. Make sure
  // that the types of the worklet operator() parameters match those in the
  // ExecutionSignature. The compiler error might help you narrow down which
  // parameter is wrong and the types that did not match.
  ReturnValueType r = ReturnValueType(worklet(p1,p2,p3,p4));

  returnFetch.Store(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo0::ControlParameterIndex>(), r);

  fetch1.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>(), p1);
  fetch2.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo2::ControlParameterIndex>(), p2);
  fetch3.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo3::ControlParameterIndex>(), p3);
  fetch4.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo4::ControlParameterIndex>(), p4);
}

template<typename WorkletType,
         typename ParameterInterface,
         typename ControlInterface,
         vtkm::IdComponent InputDomainIndex,
         typename OutputToInputMapType,
         typename VisitArrayType,
         typename ThreadIndicesType,
         typename P1,
         typename P2,
         typename P3,
         typename P4>
VTKM_EXEC_EXPORT
void DoWorkletInvokeFunctor(
      const WorkletType &worklet,
      const vtkm::internal::Invocation<
        ParameterInterface,
        ControlInterface,
        vtkm::internal::FunctionInterface<void(P1,P2,P3,P4)>,
        InputDomainIndex,
        OutputToInputMapType,
        VisitArrayType> &invocation,
      const ThreadIndicesType &threadIndices)
{
  typedef vtkm::internal::Invocation<
      ParameterInterface,
      ControlInterface,
      vtkm::internal::FunctionInterface<void(P1,P2,P3,P4)>,
      InputDomainIndex,
      OutputToInputMapType,
      VisitArrayType> Invocation;

  typedef InvocationToFetch<ThreadIndicesType,Invocation,1> FetchInfo1;
  typedef typename FetchInfo1::type FetchType1;
  FetchType1 fetch1;
  typename FetchType1::ValueType p1 =
      fetch1.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,2> FetchInfo2;
  typedef typename FetchInfo2::type FetchType2;
  FetchType2 fetch2;
  typename FetchType2::ValueType p2 =
      fetch2.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo2::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,3> FetchInfo3;
  typedef typename FetchInfo3::type FetchType3;
  FetchType3 fetch3;
  typename FetchType3::ValueType p3 =
      fetch3.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo3::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,4> FetchInfo4;
  typedef typename FetchInfo4::type FetchType4;
  FetchType4 fetch4;
  typename FetchType4::ValueType p4 =
      fetch4.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo4::ControlParameterIndex>());

  // If you got a compile error on the following line, it probably means that
  // the operator() of a worklet does not match the definition expected. One
  // common problem is that the operator() method must be declared const. Check
  // to make sure the "const" keyword is after parameters. Another common
  // problem is that the type of one or more parameters is incompatible with
  // the actual type that VTK-m creates in the execution environment. Make sure
  // that the types of the worklet operator() parameters match those in the
  // ExecutionSignature. The compiler error might help you narrow down which
  // parameter is wrong and the types that did not match.
  worklet(p1,p2,p3,p4);

  fetch1.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>(), p1);
  fetch2.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo2::ControlParameterIndex>(), p2);
  fetch3.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo3::ControlParameterIndex>(), p3);
  fetch4.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo4::ControlParameterIndex>(), p4);
}

template<typename WorkletType,
         typename ParameterInterface,
         typename ControlInterface,
         vtkm::IdComponent InputDomainIndex,
         typename OutputToInputMapType,
         typename VisitArrayType,
         typename ThreadIndicesType,
         typename R,
         typename P1,
         typename P2,
         typename P3,
         typename P4,
         typename P5>
VTKM_EXEC_EXPORT
void DoWorkletInvokeFunctor(
      const WorkletType &worklet,
      const vtkm::internal::Invocation<
        ParameterInterface,
        ControlInterface,
        vtkm::internal::FunctionInterface<R(P1,P2,P3,P4,P5)>,
        InputDomainIndex,
        OutputToInputMapType,
        VisitArrayType> &invocation,
      const ThreadIndicesType &threadIndices)
{
  typedef vtkm::internal::Invocation<
      ParameterInterface,
      ControlInterface,
      vtkm::internal::FunctionInterface<R(P1,P2,P3,P4,P5)>,
      InputDomainIndex,
      OutputToInputMapType,
      VisitArrayType> Invocation;

  typedef InvocationToFetch<ThreadIndicesType,Invocation,1> FetchInfo1;
  typedef typename FetchInfo1::type FetchType1;
  FetchType1 fetch1;
  typename FetchType1::ValueType p1 =
      fetch1.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,2> FetchInfo2;
  typedef typename FetchInfo2::type FetchType2;
  FetchType2 fetch2;
  typename FetchType2::ValueType p2 =
      fetch2.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo2::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,3> FetchInfo3;
  typedef typename FetchInfo3::type FetchType3;
  FetchType3 fetch3;
  typename FetchType3::ValueType p3 =
      fetch3.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo3::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,4> FetchInfo4;
  typedef typename FetchInfo4::type FetchType4;
  FetchType4 fetch4;
  typename FetchType4::ValueType p4 =
      fetch4.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo4::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,5> FetchInfo5;
  typedef typename FetchInfo5::type FetchType5;
  FetchType5 fetch5;
  typename FetchType5::ValueType p5 =
      fetch5.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo5::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,0> FetchInfo0;
  typedef typename FetchInfo0::type ReturnFetchType;
  typedef typename ReturnFetchType::ValueType ReturnValueType;
  ReturnFetchType returnFetch;
  // If you got a compile error on the following line, it probably means that
  // the operator() of a worklet does not match the definition expected. One
  // common problem is that the operator() method must be declared const. Check
  // to make sure the "const" keyword is after parameters. Another common
  // problem is that the type of one or more parameters is incompatible with
  // the actual type that VTK-m creates in the execution environment. Make sure
  // that the types of the worklet operator() parameters match those in the
  // ExecutionSignature. The compiler error might help you narrow down which
  // parameter is wrong and the types that did not match.
  ReturnValueType r = ReturnValueType(worklet(p1,p2,p3,p4,p5));

  returnFetch.Store(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo0::ControlParameterIndex>(), r);

  fetch1.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>(), p1);
  fetch2.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo2::ControlParameterIndex>(), p2);
  fetch3.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo3::ControlParameterIndex>(), p3);
  fetch4.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo4::ControlParameterIndex>(), p4);
  fetch5.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo5::ControlParameterIndex>(), p5);
}

template<typename WorkletType,
         typename ParameterInterface,
         typename ControlInterface,
         vtkm::IdComponent InputDomainIndex,
         typename OutputToInputMapType,
         typename VisitArrayType,
         typename ThreadIndicesType,
         typename P1,
         typename P2,
         typename P3,
         typename P4,
         typename P5>
VTKM_EXEC_EXPORT
void DoWorkletInvokeFunctor(
      const WorkletType &worklet,
      const vtkm::internal::Invocation<
        ParameterInterface,
        ControlInterface,
        vtkm::internal::FunctionInterface<void(P1,P2,P3,P4,P5)>,
        InputDomainIndex,
        OutputToInputMapType,
        VisitArrayType> &invocation,
      const ThreadIndicesType &threadIndices)
{
  typedef vtkm::internal::Invocation<
      ParameterInterface,
      ControlInterface,
      vtkm::internal::FunctionInterface<void(P1,P2,P3,P4,P5)>,
      InputDomainIndex,
      OutputToInputMapType,
      VisitArrayType> Invocation;

  typedef InvocationToFetch<ThreadIndicesType,Invocation,1> FetchInfo1;
  typedef typename FetchInfo1::type FetchType1;
  FetchType1 fetch1;
  typename FetchType1::ValueType p1 =
      fetch1.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,2> FetchInfo2;
  typedef typename FetchInfo2::type FetchType2;
  FetchType2 fetch2;
  typename FetchType2::ValueType p2 =
      fetch2.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo2::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,3> FetchInfo3;
  typedef typename FetchInfo3::type FetchType3;
  FetchType3 fetch3;
  typename FetchType3::ValueType p3 =
      fetch3.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo3::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,4> FetchInfo4;
  typedef typename FetchInfo4::type FetchType4;
  FetchType4 fetch4;
  typename FetchType4::ValueType p4 =
      fetch4.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo4::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,5> FetchInfo5;
  typedef typename FetchInfo5::type FetchType5;
  FetchType5 fetch5;
  typename FetchType5::ValueType p5 =
      fetch5.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo5::ControlParameterIndex>());

  // If you got a compile error on the following line, it probably means that
  // the operator() of a worklet does not match the definition expected. One
  // common problem is that the operator() method must be declared const. Check
  // to make sure the "const" keyword is after parameters. Another common
  // problem is that the type of one or more parameters is incompatible with
  // the actual type that VTK-m creates in the execution environment. Make sure
  // that the types of the worklet operator() parameters match those in the
  // ExecutionSignature. The compiler error might help you narrow down which
  // parameter is wrong and the types that did not match.
  worklet(p1,p2,p3,p4,p5);

  fetch1.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>(), p1);
  fetch2.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo2::ControlParameterIndex>(), p2);
  fetch3.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo3::ControlParameterIndex>(), p3);
  fetch4.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo4::ControlParameterIndex>(), p4);
  fetch5.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo5::ControlParameterIndex>(), p5);
}

template<typename WorkletType,
         typename ParameterInterface,
         typename ControlInterface,
         vtkm::IdComponent InputDomainIndex,
         typename OutputToInputMapType,
         typename VisitArrayType,
         typename ThreadIndicesType,
         typename R,
         typename P1,
         typename P2,
         typename P3,
         typename P4,
         typename P5,
         typename P6>
VTKM_EXEC_EXPORT
void DoWorkletInvokeFunctor(
      const WorkletType &worklet,
      const vtkm::internal::Invocation<
        ParameterInterface,
        ControlInterface,
        vtkm::internal::FunctionInterface<R(P1,P2,P3,P4,P5,P6)>,
        InputDomainIndex,
        OutputToInputMapType,
        VisitArrayType> &invocation,
      const ThreadIndicesType &threadIndices)
{
  typedef vtkm::internal::Invocation<
      ParameterInterface,
      ControlInterface,
      vtkm::internal::FunctionInterface<R(P1,P2,P3,P4,P5,P6)>,
      InputDomainIndex,
      OutputToInputMapType,
      VisitArrayType> Invocation;

  typedef InvocationToFetch<ThreadIndicesType,Invocation,1> FetchInfo1;
  typedef typename FetchInfo1::type FetchType1;
  FetchType1 fetch1;
  typename FetchType1::ValueType p1 =
      fetch1.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,2> FetchInfo2;
  typedef typename FetchInfo2::type FetchType2;
  FetchType2 fetch2;
  typename FetchType2::ValueType p2 =
      fetch2.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo2::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,3> FetchInfo3;
  typedef typename FetchInfo3::type FetchType3;
  FetchType3 fetch3;
  typename FetchType3::ValueType p3 =
      fetch3.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo3::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,4> FetchInfo4;
  typedef typename FetchInfo4::type FetchType4;
  FetchType4 fetch4;
  typename FetchType4::ValueType p4 =
      fetch4.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo4::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,5> FetchInfo5;
  typedef typename FetchInfo5::type FetchType5;
  FetchType5 fetch5;
  typename FetchType5::ValueType p5 =
      fetch5.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo5::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,6> FetchInfo6;
  typedef typename FetchInfo6::type FetchType6;
  FetchType6 fetch6;
  typename FetchType6::ValueType p6 =
      fetch6.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo6::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,0> FetchInfo0;
  typedef typename FetchInfo0::type ReturnFetchType;
  typedef typename ReturnFetchType::ValueType ReturnValueType;
  ReturnFetchType returnFetch;
  // If you got a compile error on the following line, it probably means that
  // the operator() of a worklet does not match the definition expected. One
  // common problem is that the operator() method must be declared const. Check
  // to make sure the "const" keyword is after parameters. Another common
  // problem is that the type of one or more parameters is incompatible with
  // the actual type that VTK-m creates in the execution environment. Make sure
  // that the types of the worklet operator() parameters match those in the
  // ExecutionSignature. The compiler error might help you narrow down which
  // parameter is wrong and the types that did not match.
  ReturnValueType r = ReturnValueType(worklet(p1,p2,p3,p4,p5,p6));

  returnFetch.Store(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo0::ControlParameterIndex>(), r);

  fetch1.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>(), p1);
  fetch2.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo2::ControlParameterIndex>(), p2);
  fetch3.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo3::ControlParameterIndex>(), p3);
  fetch4.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo4::ControlParameterIndex>(), p4);
  fetch5.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo5::ControlParameterIndex>(), p5);
  fetch6.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo6::ControlParameterIndex>(), p6);
}

template<typename WorkletType,
         typename ParameterInterface,
         typename ControlInterface,
         vtkm::IdComponent InputDomainIndex,
         typename OutputToInputMapType,
         typename VisitArrayType,
         typename ThreadIndicesType,
         typename P1,
         typename P2,
         typename P3,
         typename P4,
         typename P5,
         typename P6>
VTKM_EXEC_EXPORT
void DoWorkletInvokeFunctor(
      const WorkletType &worklet,
      const vtkm::internal::Invocation<
        ParameterInterface,
        ControlInterface,
        vtkm::internal::FunctionInterface<void(P1,P2,P3,P4,P5,P6)>,
        InputDomainIndex,
        OutputToInputMapType,
        VisitArrayType> &invocation,
      const ThreadIndicesType &threadIndices)
{
  typedef vtkm::internal::Invocation<
      ParameterInterface,
      ControlInterface,
      vtkm::internal::FunctionInterface<void(P1,P2,P3,P4,P5,P6)>,
      InputDomainIndex,
      OutputToInputMapType,
      VisitArrayType> Invocation;

  typedef InvocationToFetch<ThreadIndicesType,Invocation,1> FetchInfo1;
  typedef typename FetchInfo1::type FetchType1;
  FetchType1 fetch1;
  typename FetchType1::ValueType p1 =
      fetch1.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,2> FetchInfo2;
  typedef typename FetchInfo2::type FetchType2;
  FetchType2 fetch2;
  typename FetchType2::ValueType p2 =
      fetch2.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo2::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,3> FetchInfo3;
  typedef typename FetchInfo3::type FetchType3;
  FetchType3 fetch3;
  typename FetchType3::ValueType p3 =
      fetch3.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo3::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,4> FetchInfo4;
  typedef typename FetchInfo4::type FetchType4;
  FetchType4 fetch4;
  typename FetchType4::ValueType p4 =
      fetch4.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo4::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,5> FetchInfo5;
  typedef typename FetchInfo5::type FetchType5;
  FetchType5 fetch5;
  typename FetchType5::ValueType p5 =
      fetch5.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo5::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,6> FetchInfo6;
  typedef typename FetchInfo6::type FetchType6;
  FetchType6 fetch6;
  typename FetchType6::ValueType p6 =
      fetch6.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo6::ControlParameterIndex>());

  // If you got a compile error on the following line, it probably means that
  // the operator() of a worklet does not match the definition expected. One
  // common problem is that the operator() method must be declared const. Check
  // to make sure the "const" keyword is after parameters. Another common
  // problem is that the type of one or more parameters is incompatible with
  // the actual type that VTK-m creates in the execution environment. Make sure
  // that the types of the worklet operator() parameters match those in the
  // ExecutionSignature. The compiler error might help you narrow down which
  // parameter is wrong and the types that did not match.
  worklet(p1,p2,p3,p4,p5,p6);

  fetch1.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>(), p1);
  fetch2.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo2::ControlParameterIndex>(), p2);
  fetch3.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo3::ControlParameterIndex>(), p3);
  fetch4.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo4::ControlParameterIndex>(), p4);
  fetch5.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo5::ControlParameterIndex>(), p5);
  fetch6.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo6::ControlParameterIndex>(), p6);
}

template<typename WorkletType,
         typename ParameterInterface,
         typename ControlInterface,
         vtkm::IdComponent InputDomainIndex,
         typename OutputToInputMapType,
         typename VisitArrayType,
         typename ThreadIndicesType,
         typename R,
         typename P1,
         typename P2,
         typename P3,
         typename P4,
         typename P5,
         typename P6,
         typename P7>
VTKM_EXEC_EXPORT
void DoWorkletInvokeFunctor(
      const WorkletType &worklet,
      const vtkm::internal::Invocation<
        ParameterInterface,
        ControlInterface,
        vtkm::internal::FunctionInterface<R(P1,P2,P3,P4,P5,P6,P7)>,
        InputDomainIndex,
        OutputToInputMapType,
        VisitArrayType> &invocation,
      const ThreadIndicesType &threadIndices)
{
  typedef vtkm::internal::Invocation<
      ParameterInterface,
      ControlInterface,
      vtkm::internal::FunctionInterface<R(P1,P2,P3,P4,P5,P6,P7)>,
      InputDomainIndex,
      OutputToInputMapType,
      VisitArrayType> Invocation;

  typedef InvocationToFetch<ThreadIndicesType,Invocation,1> FetchInfo1;
  typedef typename FetchInfo1::type FetchType1;
  FetchType1 fetch1;
  typename FetchType1::ValueType p1 =
      fetch1.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,2> FetchInfo2;
  typedef typename FetchInfo2::type FetchType2;
  FetchType2 fetch2;
  typename FetchType2::ValueType p2 =
      fetch2.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo2::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,3> FetchInfo3;
  typedef typename FetchInfo3::type FetchType3;
  FetchType3 fetch3;
  typename FetchType3::ValueType p3 =
      fetch3.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo3::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,4> FetchInfo4;
  typedef typename FetchInfo4::type FetchType4;
  FetchType4 fetch4;
  typename FetchType4::ValueType p4 =
      fetch4.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo4::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,5> FetchInfo5;
  typedef typename FetchInfo5::type FetchType5;
  FetchType5 fetch5;
  typename FetchType5::ValueType p5 =
      fetch5.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo5::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,6> FetchInfo6;
  typedef typename FetchInfo6::type FetchType6;
  FetchType6 fetch6;
  typename FetchType6::ValueType p6 =
      fetch6.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo6::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,7> FetchInfo7;
  typedef typename FetchInfo7::type FetchType7;
  FetchType7 fetch7;
  typename FetchType7::ValueType p7 =
      fetch7.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo7::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,0> FetchInfo0;
  typedef typename FetchInfo0::type ReturnFetchType;
  typedef typename ReturnFetchType::ValueType ReturnValueType;
  ReturnFetchType returnFetch;
  // If you got a compile error on the following line, it probably means that
  // the operator() of a worklet does not match the definition expected. One
  // common problem is that the operator() method must be declared const. Check
  // to make sure the "const" keyword is after parameters. Another common
  // problem is that the type of one or more parameters is incompatible with
  // the actual type that VTK-m creates in the execution environment. Make sure
  // that the types of the worklet operator() parameters match those in the
  // ExecutionSignature. The compiler error might help you narrow down which
  // parameter is wrong and the types that did not match.
  ReturnValueType r = ReturnValueType(worklet(p1,p2,p3,p4,p5,p6,p7));

  returnFetch.Store(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo0::ControlParameterIndex>(), r);

  fetch1.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>(), p1);
  fetch2.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo2::ControlParameterIndex>(), p2);
  fetch3.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo3::ControlParameterIndex>(), p3);
  fetch4.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo4::ControlParameterIndex>(), p4);
  fetch5.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo5::ControlParameterIndex>(), p5);
  fetch6.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo6::ControlParameterIndex>(), p6);
  fetch7.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo7::ControlParameterIndex>(), p7);
}

template<typename WorkletType,
         typename ParameterInterface,
         typename ControlInterface,
         vtkm::IdComponent InputDomainIndex,
         typename OutputToInputMapType,
         typename VisitArrayType,
         typename ThreadIndicesType,
         typename P1,
         typename P2,
         typename P3,
         typename P4,
         typename P5,
         typename P6,
         typename P7>
VTKM_EXEC_EXPORT
void DoWorkletInvokeFunctor(
      const WorkletType &worklet,
      const vtkm::internal::Invocation<
        ParameterInterface,
        ControlInterface,
        vtkm::internal::FunctionInterface<void(P1,P2,P3,P4,P5,P6,P7)>,
        InputDomainIndex,
        OutputToInputMapType,
        VisitArrayType> &invocation,
      const ThreadIndicesType &threadIndices)
{
  typedef vtkm::internal::Invocation<
      ParameterInterface,
      ControlInterface,
      vtkm::internal::FunctionInterface<void(P1,P2,P3,P4,P5,P6,P7)>,
      InputDomainIndex,
      OutputToInputMapType,
      VisitArrayType> Invocation;

  typedef InvocationToFetch<ThreadIndicesType,Invocation,1> FetchInfo1;
  typedef typename FetchInfo1::type FetchType1;
  FetchType1 fetch1;
  typename FetchType1::ValueType p1 =
      fetch1.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,2> FetchInfo2;
  typedef typename FetchInfo2::type FetchType2;
  FetchType2 fetch2;
  typename FetchType2::ValueType p2 =
      fetch2.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo2::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,3> FetchInfo3;
  typedef typename FetchInfo3::type FetchType3;
  FetchType3 fetch3;
  typename FetchType3::ValueType p3 =
      fetch3.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo3::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,4> FetchInfo4;
  typedef typename FetchInfo4::type FetchType4;
  FetchType4 fetch4;
  typename FetchType4::ValueType p4 =
      fetch4.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo4::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,5> FetchInfo5;
  typedef typename FetchInfo5::type FetchType5;
  FetchType5 fetch5;
  typename FetchType5::ValueType p5 =
      fetch5.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo5::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,6> FetchInfo6;
  typedef typename FetchInfo6::type FetchType6;
  FetchType6 fetch6;
  typename FetchType6::ValueType p6 =
      fetch6.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo6::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,7> FetchInfo7;
  typedef typename FetchInfo7::type FetchType7;
  FetchType7 fetch7;
  typename FetchType7::ValueType p7 =
      fetch7.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo7::ControlParameterIndex>());

  // If you got a compile error on the following line, it probably means that
  // the operator() of a worklet does not match the definition expected. One
  // common problem is that the operator() method must be declared const. Check
  // to make sure the "const" keyword is after parameters. Another common
  // problem is that the type of one or more parameters is incompatible with
  // the actual type that VTK-m creates in the execution environment. Make sure
  // that the types of the worklet operator() parameters match those in the
  // ExecutionSignature. The compiler error might help you narrow down which
  // parameter is wrong and the types that did not match.
  worklet(p1,p2,p3,p4,p5,p6,p7);

  fetch1.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>(), p1);
  fetch2.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo2::ControlParameterIndex>(), p2);
  fetch3.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo3::ControlParameterIndex>(), p3);
  fetch4.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo4::ControlParameterIndex>(), p4);
  fetch5.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo5::ControlParameterIndex>(), p5);
  fetch6.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo6::ControlParameterIndex>(), p6);
  fetch7.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo7::ControlParameterIndex>(), p7);
}

template<typename WorkletType,
         typename ParameterInterface,
         typename ControlInterface,
         vtkm::IdComponent InputDomainIndex,
         typename OutputToInputMapType,
         typename VisitArrayType,
         typename ThreadIndicesType,
         typename R,
         typename P1,
         typename P2,
         typename P3,
         typename P4,
         typename P5,
         typename P6,
         typename P7,
         typename P8>
VTKM_EXEC_EXPORT
void DoWorkletInvokeFunctor(
      const WorkletType &worklet,
      const vtkm::internal::Invocation<
        ParameterInterface,
        ControlInterface,
        vtkm::internal::FunctionInterface<R(P1,P2,P3,P4,P5,P6,P7,P8)>,
        InputDomainIndex,
        OutputToInputMapType,
        VisitArrayType> &invocation,
      const ThreadIndicesType &threadIndices)
{
  typedef vtkm::internal::Invocation<
      ParameterInterface,
      ControlInterface,
      vtkm::internal::FunctionInterface<R(P1,P2,P3,P4,P5,P6,P7,P8)>,
      InputDomainIndex,
      OutputToInputMapType,
      VisitArrayType> Invocation;

  typedef InvocationToFetch<ThreadIndicesType,Invocation,1> FetchInfo1;
  typedef typename FetchInfo1::type FetchType1;
  FetchType1 fetch1;
  typename FetchType1::ValueType p1 =
      fetch1.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,2> FetchInfo2;
  typedef typename FetchInfo2::type FetchType2;
  FetchType2 fetch2;
  typename FetchType2::ValueType p2 =
      fetch2.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo2::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,3> FetchInfo3;
  typedef typename FetchInfo3::type FetchType3;
  FetchType3 fetch3;
  typename FetchType3::ValueType p3 =
      fetch3.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo3::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,4> FetchInfo4;
  typedef typename FetchInfo4::type FetchType4;
  FetchType4 fetch4;
  typename FetchType4::ValueType p4 =
      fetch4.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo4::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,5> FetchInfo5;
  typedef typename FetchInfo5::type FetchType5;
  FetchType5 fetch5;
  typename FetchType5::ValueType p5 =
      fetch5.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo5::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,6> FetchInfo6;
  typedef typename FetchInfo6::type FetchType6;
  FetchType6 fetch6;
  typename FetchType6::ValueType p6 =
      fetch6.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo6::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,7> FetchInfo7;
  typedef typename FetchInfo7::type FetchType7;
  FetchType7 fetch7;
  typename FetchType7::ValueType p7 =
      fetch7.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo7::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,8> FetchInfo8;
  typedef typename FetchInfo8::type FetchType8;
  FetchType8 fetch8;
  typename FetchType8::ValueType p8 =
      fetch8.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo8::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,0> FetchInfo0;
  typedef typename FetchInfo0::type ReturnFetchType;
  typedef typename ReturnFetchType::ValueType ReturnValueType;
  ReturnFetchType returnFetch;
  // If you got a compile error on the following line, it probably means that
  // the operator() of a worklet does not match the definition expected. One
  // common problem is that the operator() method must be declared const. Check
  // to make sure the "const" keyword is after parameters. Another common
  // problem is that the type of one or more parameters is incompatible with
  // the actual type that VTK-m creates in the execution environment. Make sure
  // that the types of the worklet operator() parameters match those in the
  // ExecutionSignature. The compiler error might help you narrow down which
  // parameter is wrong and the types that did not match.
  ReturnValueType r = ReturnValueType(worklet(p1,p2,p3,p4,p5,p6,p7,p8));

  returnFetch.Store(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo0::ControlParameterIndex>(), r);

  fetch1.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>(), p1);
  fetch2.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo2::ControlParameterIndex>(), p2);
  fetch3.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo3::ControlParameterIndex>(), p3);
  fetch4.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo4::ControlParameterIndex>(), p4);
  fetch5.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo5::ControlParameterIndex>(), p5);
  fetch6.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo6::ControlParameterIndex>(), p6);
  fetch7.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo7::ControlParameterIndex>(), p7);
  fetch8.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo8::ControlParameterIndex>(), p8);
}

template<typename WorkletType,
         typename ParameterInterface,
         typename ControlInterface,
         vtkm::IdComponent InputDomainIndex,
         typename OutputToInputMapType,
         typename VisitArrayType,
         typename ThreadIndicesType,
         typename P1,
         typename P2,
         typename P3,
         typename P4,
         typename P5,
         typename P6,
         typename P7,
         typename P8>
VTKM_EXEC_EXPORT
void DoWorkletInvokeFunctor(
      const WorkletType &worklet,
      const vtkm::internal::Invocation<
        ParameterInterface,
        ControlInterface,
        vtkm::internal::FunctionInterface<void(P1,P2,P3,P4,P5,P6,P7,P8)>,
        InputDomainIndex,
        OutputToInputMapType,
        VisitArrayType> &invocation,
      const ThreadIndicesType &threadIndices)
{
  typedef vtkm::internal::Invocation<
      ParameterInterface,
      ControlInterface,
      vtkm::internal::FunctionInterface<void(P1,P2,P3,P4,P5,P6,P7,P8)>,
      InputDomainIndex,
      OutputToInputMapType,
      VisitArrayType> Invocation;

  typedef InvocationToFetch<ThreadIndicesType,Invocation,1> FetchInfo1;
  typedef typename FetchInfo1::type FetchType1;
  FetchType1 fetch1;
  typename FetchType1::ValueType p1 =
      fetch1.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,2> FetchInfo2;
  typedef typename FetchInfo2::type FetchType2;
  FetchType2 fetch2;
  typename FetchType2::ValueType p2 =
      fetch2.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo2::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,3> FetchInfo3;
  typedef typename FetchInfo3::type FetchType3;
  FetchType3 fetch3;
  typename FetchType3::ValueType p3 =
      fetch3.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo3::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,4> FetchInfo4;
  typedef typename FetchInfo4::type FetchType4;
  FetchType4 fetch4;
  typename FetchType4::ValueType p4 =
      fetch4.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo4::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,5> FetchInfo5;
  typedef typename FetchInfo5::type FetchType5;
  FetchType5 fetch5;
  typename FetchType5::ValueType p5 =
      fetch5.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo5::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,6> FetchInfo6;
  typedef typename FetchInfo6::type FetchType6;
  FetchType6 fetch6;
  typename FetchType6::ValueType p6 =
      fetch6.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo6::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,7> FetchInfo7;
  typedef typename FetchInfo7::type FetchType7;
  FetchType7 fetch7;
  typename FetchType7::ValueType p7 =
      fetch7.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo7::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,8> FetchInfo8;
  typedef typename FetchInfo8::type FetchType8;
  FetchType8 fetch8;
  typename FetchType8::ValueType p8 =
      fetch8.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo8::ControlParameterIndex>());

  // If you got a compile error on the following line, it probably means that
  // the operator() of a worklet does not match the definition expected. One
  // common problem is that the operator() method must be declared const. Check
  // to make sure the "const" keyword is after parameters. Another common
  // problem is that the type of one or more parameters is incompatible with
  // the actual type that VTK-m creates in the execution environment. Make sure
  // that the types of the worklet operator() parameters match those in the
  // ExecutionSignature. The compiler error might help you narrow down which
  // parameter is wrong and the types that did not match.
  worklet(p1,p2,p3,p4,p5,p6,p7,p8);

  fetch1.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>(), p1);
  fetch2.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo2::ControlParameterIndex>(), p2);
  fetch3.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo3::ControlParameterIndex>(), p3);
  fetch4.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo4::ControlParameterIndex>(), p4);
  fetch5.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo5::ControlParameterIndex>(), p5);
  fetch6.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo6::ControlParameterIndex>(), p6);
  fetch7.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo7::ControlParameterIndex>(), p7);
  fetch8.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo8::ControlParameterIndex>(), p8);
}

template<typename WorkletType,
         typename ParameterInterface,
         typename ControlInterface,
         vtkm::IdComponent InputDomainIndex,
         typename OutputToInputMapType,
         typename VisitArrayType,
         typename ThreadIndicesType,
         typename R,
         typename P1,
         typename P2,
         typename P3,
         typename P4,
         typename P5,
         typename P6,
         typename P7,
         typename P8,
         typename P9>
VTKM_EXEC_EXPORT
void DoWorkletInvokeFunctor(
      const WorkletType &worklet,
      const vtkm::internal::Invocation<
        ParameterInterface,
        ControlInterface,
        vtkm::internal::FunctionInterface<R(P1,P2,P3,P4,P5,P6,P7,P8,P9)>,
        InputDomainIndex,
        OutputToInputMapType,
        VisitArrayType> &invocation,
      const ThreadIndicesType &threadIndices)
{
  typedef vtkm::internal::Invocation<
      ParameterInterface,
      ControlInterface,
      vtkm::internal::FunctionInterface<R(P1,P2,P3,P4,P5,P6,P7,P8,P9)>,
      InputDomainIndex,
      OutputToInputMapType,
      VisitArrayType> Invocation;

  typedef InvocationToFetch<ThreadIndicesType,Invocation,1> FetchInfo1;
  typedef typename FetchInfo1::type FetchType1;
  FetchType1 fetch1;
  typename FetchType1::ValueType p1 =
      fetch1.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,2> FetchInfo2;
  typedef typename FetchInfo2::type FetchType2;
  FetchType2 fetch2;
  typename FetchType2::ValueType p2 =
      fetch2.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo2::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,3> FetchInfo3;
  typedef typename FetchInfo3::type FetchType3;
  FetchType3 fetch3;
  typename FetchType3::ValueType p3 =
      fetch3.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo3::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,4> FetchInfo4;
  typedef typename FetchInfo4::type FetchType4;
  FetchType4 fetch4;
  typename FetchType4::ValueType p4 =
      fetch4.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo4::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,5> FetchInfo5;
  typedef typename FetchInfo5::type FetchType5;
  FetchType5 fetch5;
  typename FetchType5::ValueType p5 =
      fetch5.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo5::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,6> FetchInfo6;
  typedef typename FetchInfo6::type FetchType6;
  FetchType6 fetch6;
  typename FetchType6::ValueType p6 =
      fetch6.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo6::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,7> FetchInfo7;
  typedef typename FetchInfo7::type FetchType7;
  FetchType7 fetch7;
  typename FetchType7::ValueType p7 =
      fetch7.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo7::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,8> FetchInfo8;
  typedef typename FetchInfo8::type FetchType8;
  FetchType8 fetch8;
  typename FetchType8::ValueType p8 =
      fetch8.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo8::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,9> FetchInfo9;
  typedef typename FetchInfo9::type FetchType9;
  FetchType9 fetch9;
  typename FetchType9::ValueType p9 =
      fetch9.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo9::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,0> FetchInfo0;
  typedef typename FetchInfo0::type ReturnFetchType;
  typedef typename ReturnFetchType::ValueType ReturnValueType;
  ReturnFetchType returnFetch;
  // If you got a compile error on the following line, it probably means that
  // the operator() of a worklet does not match the definition expected. One
  // common problem is that the operator() method must be declared const. Check
  // to make sure the "const" keyword is after parameters. Another common
  // problem is that the type of one or more parameters is incompatible with
  // the actual type that VTK-m creates in the execution environment. Make sure
  // that the types of the worklet operator() parameters match those in the
  // ExecutionSignature. The compiler error might help you narrow down which
  // parameter is wrong and the types that did not match.
  ReturnValueType r = ReturnValueType(worklet(p1,p2,p3,p4,p5,p6,p7,p8,p9));

  returnFetch.Store(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo0::ControlParameterIndex>(), r);

  fetch1.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>(), p1);
  fetch2.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo2::ControlParameterIndex>(), p2);
  fetch3.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo3::ControlParameterIndex>(), p3);
  fetch4.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo4::ControlParameterIndex>(), p4);
  fetch5.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo5::ControlParameterIndex>(), p5);
  fetch6.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo6::ControlParameterIndex>(), p6);
  fetch7.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo7::ControlParameterIndex>(), p7);
  fetch8.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo8::ControlParameterIndex>(), p8);
  fetch9.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo9::ControlParameterIndex>(), p9);
}

template<typename WorkletType,
         typename ParameterInterface,
         typename ControlInterface,
         vtkm::IdComponent InputDomainIndex,
         typename OutputToInputMapType,
         typename VisitArrayType,
         typename ThreadIndicesType,
         typename P1,
         typename P2,
         typename P3,
         typename P4,
         typename P5,
         typename P6,
         typename P7,
         typename P8,
         typename P9>
VTKM_EXEC_EXPORT
void DoWorkletInvokeFunctor(
      const WorkletType &worklet,
      const vtkm::internal::Invocation<
        ParameterInterface,
        ControlInterface,
        vtkm::internal::FunctionInterface<void(P1,P2,P3,P4,P5,P6,P7,P8,P9)>,
        InputDomainIndex,
        OutputToInputMapType,
        VisitArrayType> &invocation,
      const ThreadIndicesType &threadIndices)
{
  typedef vtkm::internal::Invocation<
      ParameterInterface,
      ControlInterface,
      vtkm::internal::FunctionInterface<void(P1,P2,P3,P4,P5,P6,P7,P8,P9)>,
      InputDomainIndex,
      OutputToInputMapType,
      VisitArrayType> Invocation;

  typedef InvocationToFetch<ThreadIndicesType,Invocation,1> FetchInfo1;
  typedef typename FetchInfo1::type FetchType1;
  FetchType1 fetch1;
  typename FetchType1::ValueType p1 =
      fetch1.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,2> FetchInfo2;
  typedef typename FetchInfo2::type FetchType2;
  FetchType2 fetch2;
  typename FetchType2::ValueType p2 =
      fetch2.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo2::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,3> FetchInfo3;
  typedef typename FetchInfo3::type FetchType3;
  FetchType3 fetch3;
  typename FetchType3::ValueType p3 =
      fetch3.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo3::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,4> FetchInfo4;
  typedef typename FetchInfo4::type FetchType4;
  FetchType4 fetch4;
  typename FetchType4::ValueType p4 =
      fetch4.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo4::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,5> FetchInfo5;
  typedef typename FetchInfo5::type FetchType5;
  FetchType5 fetch5;
  typename FetchType5::ValueType p5 =
      fetch5.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo5::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,6> FetchInfo6;
  typedef typename FetchInfo6::type FetchType6;
  FetchType6 fetch6;
  typename FetchType6::ValueType p6 =
      fetch6.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo6::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,7> FetchInfo7;
  typedef typename FetchInfo7::type FetchType7;
  FetchType7 fetch7;
  typename FetchType7::ValueType p7 =
      fetch7.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo7::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,8> FetchInfo8;
  typedef typename FetchInfo8::type FetchType8;
  FetchType8 fetch8;
  typename FetchType8::ValueType p8 =
      fetch8.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo8::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,9> FetchInfo9;
  typedef typename FetchInfo9::type FetchType9;
  FetchType9 fetch9;
  typename FetchType9::ValueType p9 =
      fetch9.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo9::ControlParameterIndex>());

  // If you got a compile error on the following line, it probably means that
  // the operator() of a worklet does not match the definition expected. One
  // common problem is that the operator() method must be declared const. Check
  // to make sure the "const" keyword is after parameters. Another common
  // problem is that the type of one or more parameters is incompatible with
  // the actual type that VTK-m creates in the execution environment. Make sure
  // that the types of the worklet operator() parameters match those in the
  // ExecutionSignature. The compiler error might help you narrow down which
  // parameter is wrong and the types that did not match.
  worklet(p1,p2,p3,p4,p5,p6,p7,p8,p9);

  fetch1.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>(), p1);
  fetch2.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo2::ControlParameterIndex>(), p2);
  fetch3.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo3::ControlParameterIndex>(), p3);
  fetch4.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo4::ControlParameterIndex>(), p4);
  fetch5.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo5::ControlParameterIndex>(), p5);
  fetch6.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo6::ControlParameterIndex>(), p6);
  fetch7.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo7::ControlParameterIndex>(), p7);
  fetch8.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo8::ControlParameterIndex>(), p8);
  fetch9.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo9::ControlParameterIndex>(), p9);
}

template<typename WorkletType,
         typename ParameterInterface,
         typename ControlInterface,
         vtkm::IdComponent InputDomainIndex,
         typename OutputToInputMapType,
         typename VisitArrayType,
         typename ThreadIndicesType,
         typename R,
         typename P1,
         typename P2,
         typename P3,
         typename P4,
         typename P5,
         typename P6,
         typename P7,
         typename P8,
         typename P9,
         typename P10>
VTKM_EXEC_EXPORT
void DoWorkletInvokeFunctor(
      const WorkletType &worklet,
      const vtkm::internal::Invocation<
        ParameterInterface,
        ControlInterface,
        vtkm::internal::FunctionInterface<R(P1,P2,P3,P4,P5,P6,P7,P8,P9,P10)>,
        InputDomainIndex,
        OutputToInputMapType,
        VisitArrayType> &invocation,
      const ThreadIndicesType &threadIndices)
{
  typedef vtkm::internal::Invocation<
      ParameterInterface,
      ControlInterface,
      vtkm::internal::FunctionInterface<R(P1,P2,P3,P4,P5,P6,P7,P8,P9,P10)>,
      InputDomainIndex,
      OutputToInputMapType,
      VisitArrayType> Invocation;

  typedef InvocationToFetch<ThreadIndicesType,Invocation,1> FetchInfo1;
  typedef typename FetchInfo1::type FetchType1;
  FetchType1 fetch1;
  typename FetchType1::ValueType p1 =
      fetch1.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,2> FetchInfo2;
  typedef typename FetchInfo2::type FetchType2;
  FetchType2 fetch2;
  typename FetchType2::ValueType p2 =
      fetch2.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo2::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,3> FetchInfo3;
  typedef typename FetchInfo3::type FetchType3;
  FetchType3 fetch3;
  typename FetchType3::ValueType p3 =
      fetch3.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo3::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,4> FetchInfo4;
  typedef typename FetchInfo4::type FetchType4;
  FetchType4 fetch4;
  typename FetchType4::ValueType p4 =
      fetch4.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo4::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,5> FetchInfo5;
  typedef typename FetchInfo5::type FetchType5;
  FetchType5 fetch5;
  typename FetchType5::ValueType p5 =
      fetch5.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo5::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,6> FetchInfo6;
  typedef typename FetchInfo6::type FetchType6;
  FetchType6 fetch6;
  typename FetchType6::ValueType p6 =
      fetch6.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo6::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,7> FetchInfo7;
  typedef typename FetchInfo7::type FetchType7;
  FetchType7 fetch7;
  typename FetchType7::ValueType p7 =
      fetch7.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo7::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,8> FetchInfo8;
  typedef typename FetchInfo8::type FetchType8;
  FetchType8 fetch8;
  typename FetchType8::ValueType p8 =
      fetch8.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo8::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,9> FetchInfo9;
  typedef typename FetchInfo9::type FetchType9;
  FetchType9 fetch9;
  typename FetchType9::ValueType p9 =
      fetch9.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo9::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,10> FetchInfo10;
  typedef typename FetchInfo10::type FetchType10;
  FetchType10 fetch10;
  typename FetchType10::ValueType p10 =
      fetch10.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo10::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,0> FetchInfo0;
  typedef typename FetchInfo0::type ReturnFetchType;
  typedef typename ReturnFetchType::ValueType ReturnValueType;
  ReturnFetchType returnFetch;
  // If you got a compile error on the following line, it probably means that
  // the operator() of a worklet does not match the definition expected. One
  // common problem is that the operator() method must be declared const. Check
  // to make sure the "const" keyword is after parameters. Another common
  // problem is that the type of one or more parameters is incompatible with
  // the actual type that VTK-m creates in the execution environment. Make sure
  // that the types of the worklet operator() parameters match those in the
  // ExecutionSignature. The compiler error might help you narrow down which
  // parameter is wrong and the types that did not match.
  ReturnValueType r = ReturnValueType(worklet(p1,p2,p3,p4,p5,p6,p7,p8,p9,p10));

  returnFetch.Store(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo0::ControlParameterIndex>(), r);

  fetch1.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>(), p1);
  fetch2.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo2::ControlParameterIndex>(), p2);
  fetch3.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo3::ControlParameterIndex>(), p3);
  fetch4.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo4::ControlParameterIndex>(), p4);
  fetch5.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo5::ControlParameterIndex>(), p5);
  fetch6.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo6::ControlParameterIndex>(), p6);
  fetch7.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo7::ControlParameterIndex>(), p7);
  fetch8.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo8::ControlParameterIndex>(), p8);
  fetch9.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo9::ControlParameterIndex>(), p9);
  fetch10.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo10::ControlParameterIndex>(), p10);
}

template<typename WorkletType,
         typename ParameterInterface,
         typename ControlInterface,
         vtkm::IdComponent InputDomainIndex,
         typename OutputToInputMapType,
         typename VisitArrayType,
         typename ThreadIndicesType,
         typename P1,
         typename P2,
         typename P3,
         typename P4,
         typename P5,
         typename P6,
         typename P7,
         typename P8,
         typename P9,
         typename P10>
VTKM_EXEC_EXPORT
void DoWorkletInvokeFunctor(
      const WorkletType &worklet,
      const vtkm::internal::Invocation<
        ParameterInterface,
        ControlInterface,
        vtkm::internal::FunctionInterface<void(P1,P2,P3,P4,P5,P6,P7,P8,P9,P10)>,
        InputDomainIndex,
        OutputToInputMapType,
        VisitArrayType> &invocation,
      const ThreadIndicesType &threadIndices)
{
  typedef vtkm::internal::Invocation<
      ParameterInterface,
      ControlInterface,
      vtkm::internal::FunctionInterface<void(P1,P2,P3,P4,P5,P6,P7,P8,P9,P10)>,
      InputDomainIndex,
      OutputToInputMapType,
      VisitArrayType> Invocation;

  typedef InvocationToFetch<ThreadIndicesType,Invocation,1> FetchInfo1;
  typedef typename FetchInfo1::type FetchType1;
  FetchType1 fetch1;
  typename FetchType1::ValueType p1 =
      fetch1.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,2> FetchInfo2;
  typedef typename FetchInfo2::type FetchType2;
  FetchType2 fetch2;
  typename FetchType2::ValueType p2 =
      fetch2.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo2::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,3> FetchInfo3;
  typedef typename FetchInfo3::type FetchType3;
  FetchType3 fetch3;
  typename FetchType3::ValueType p3 =
      fetch3.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo3::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,4> FetchInfo4;
  typedef typename FetchInfo4::type FetchType4;
  FetchType4 fetch4;
  typename FetchType4::ValueType p4 =
      fetch4.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo4::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,5> FetchInfo5;
  typedef typename FetchInfo5::type FetchType5;
  FetchType5 fetch5;
  typename FetchType5::ValueType p5 =
      fetch5.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo5::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,6> FetchInfo6;
  typedef typename FetchInfo6::type FetchType6;
  FetchType6 fetch6;
  typename FetchType6::ValueType p6 =
      fetch6.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo6::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,7> FetchInfo7;
  typedef typename FetchInfo7::type FetchType7;
  FetchType7 fetch7;
  typename FetchType7::ValueType p7 =
      fetch7.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo7::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,8> FetchInfo8;
  typedef typename FetchInfo8::type FetchType8;
  FetchType8 fetch8;
  typename FetchType8::ValueType p8 =
      fetch8.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo8::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,9> FetchInfo9;
  typedef typename FetchInfo9::type FetchType9;
  FetchType9 fetch9;
  typename FetchType9::ValueType p9 =
      fetch9.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo9::ControlParameterIndex>());

  typedef InvocationToFetch<ThreadIndicesType,Invocation,10> FetchInfo10;
  typedef typename FetchInfo10::type FetchType10;
  FetchType10 fetch10;
  typename FetchType10::ValueType p10 =
      fetch10.Load(
        threadIndices, invocation.Parameters.template GetParameter<FetchInfo10::ControlParameterIndex>());

  // If you got a compile error on the following line, it probably means that
  // the operator() of a worklet does not match the definition expected. One
  // common problem is that the operator() method must be declared const. Check
  // to make sure the "const" keyword is after parameters. Another common
  // problem is that the type of one or more parameters is incompatible with
  // the actual type that VTK-m creates in the execution environment. Make sure
  // that the types of the worklet operator() parameters match those in the
  // ExecutionSignature. The compiler error might help you narrow down which
  // parameter is wrong and the types that did not match.
  worklet(p1,p2,p3,p4,p5,p6,p7,p8,p9,p10);

  fetch1.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo1::ControlParameterIndex>(), p1);
  fetch2.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo2::ControlParameterIndex>(), p2);
  fetch3.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo3::ControlParameterIndex>(), p3);
  fetch4.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo4::ControlParameterIndex>(), p4);
  fetch5.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo5::ControlParameterIndex>(), p5);
  fetch6.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo6::ControlParameterIndex>(), p6);
  fetch7.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo7::ControlParameterIndex>(), p7);
  fetch8.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo8::ControlParameterIndex>(), p8);
  fetch9.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo9::ControlParameterIndex>(), p9);
  fetch10.Store(
      threadIndices, invocation.Parameters.template GetParameter<FetchInfo10::ControlParameterIndex>(), p10);
}


}
}
}
} // namespace vtkm::exec::internal::detail

#endif //vtk_m_exec_internal_WorkletInvokeFunctorDetail_h
