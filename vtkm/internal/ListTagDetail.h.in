//============================================================================
//  Copyright (c) Kitware, Inc.
//  All rights reserved.
//  See LICENSE.txt for details.
//  This software is distributed WITHOUT ANY WARRANTY; without even
//  the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
//  PURPOSE.  See the above copyright notice for more information.
//
//  Copyright 2014 Sandia Corporation.
//  Copyright 2014 UT-Battelle, LLC.
//  Copyright 2014 Los Alamos National Security.
//
//  Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
//  the U.S. Government retains certain rights in this software.
//
//  Under the terms of Contract DE-AC52-06NA25396 with Los Alamos National
//  Laboratory (LANL), the U.S. Government retains certain rights in
//  this software.
//============================================================================
$# This file uses the pyexpander macro processing utility to build the
$# FunctionInterface facilities that use a variable number of arguments.
$# Information, documentation, and downloads for pyexpander can be found at:
$#
$#     http://pyexpander.sourceforge.net/
$#
$# To build the source code, execute the following (after installing
$# pyexpander, of course):
$#
$#     expander.py ListTagDetail.h.in > ListTagDetail.h
$#
$# Ignore the following comment. It is meant for the generated file.
// **** DO NOT EDIT THIS FILE!!! ****
// This file is automatically generated by FunctionInterfaceDetailPre.h.in

#ifndef vtk_m_internal_ListTagDetail_h
#define vtk_m_internal_ListTagDetail_h

#if !defined(vtk_m_ListTag_h) && !defined(VTKM_TEST_HEADER_BUILD)
#error ListTagDetail.h must be included from ListTag.h
#endif

#include <vtkm/Types.h>

$py(max_base_list=15)\
#define VTKM_MAX_BASE_LIST $(max_base_list)

$# Python commands used in template expansion.
$py(
def comma_if(flag):
  if flag:
    return ','
  else:
    return '';

def template_params(num_params, name='T', start=1, default=''):
  if num_params < start:
    return ''
  result = 'typename %s%d%s' % (name, start, default)
  for param in xrange(start+1, num_params+1):
    result += ',\n         typename %s%d%s' % (name, param, default)
  return result

def param_list(num_params, name='T', start=1):
  if num_params < start:
    return ''
  result = '%s%d' % (name, start)
  for param in xrange(start+1, num_params+1):
    result += ',%s%d' % (name, param)
  return result

def signature(num_params, name='T', return_type='void', start=1):
  result = '%s(' % return_type
  if num_params >= start:
    result += '%s%d' % (name, start)
  for param in xrange(start+1, num_params+1):
    result += ',%s%d' % (name, param)
  result += ')'
  return result
)\
$#
$extend(comma_if, param_list, template_params, signature)\

namespace vtkm {

namespace detail {

//-----------------------------------------------------------------------------

/// Base class that all ListTag classes inherit from. Helps identify lists
/// in macros like VTKM_IS_LIST_TAG.
///
struct ListRoot {  };

template<typename signature>
struct ListBase {  };

//-----------------------------------------------------------------------------

template<typename Functor>
VTKM_CONT_EXPORT
void ListForEachImpl(const Functor &, ListBase<void()>) {  }

$for(num_params in xrange(1, max_base_list+1))\
template<typename Functor,
         $template_params(num_params)>
VTKM_CONT_EXPORT
void ListForEachImpl(Functor &f, ListBase<void($param_list(num_params))>)
{
$for(param_index in range(1, num_params+1))\
  f(T$(param_index)());
$endfor\
}

template<typename Functor,
         $template_params(num_params)>
VTKM_CONT_EXPORT
void ListForEachImpl(const Functor &f, ListBase<void($param_list(num_params))>)
{
$for(param_index in range(1, num_params+1))\
  f(T$(param_index)());
$endfor\
}

$endfor\

//-----------------------------------------------------------------------------

template<typename List, typename Type>
struct ListContainsImpl;

template<typename Type>
struct ListContainsImpl<ListBase<void()>, Type>
{
  static const bool value = false;
};

template<typename Type>
struct ListContainsImpl<ListBase<void(Type)>, Type>
{
  static const bool value = true;
};

template<typename Type, typename T1>
struct ListContainsImpl<ListBase<void(T1)>, Type>
{
  static const bool value = false;
};

$for(num_params in xrange(2, max_base_list+1))\
template<typename Type,
         $template_params(num_params, start=2)>
struct ListContainsImpl<ListBase<void(Type,$param_list(num_params, start=2))>, Type>
{
  static const bool value = true;
};

template<typename Type,
         $template_params(num_params)>
struct ListContainsImpl<ListBase<$signature(num_params)>, Type>
{
  static const bool value =
      ListContainsImpl<ListBase<$signature(num_params, start=2)>, Type>::value;
};

$endfor\

} // namespace detail

//-----------------------------------------------------------------------------

/// A basic tag for a list of typenames. This struct can be subclassed
/// and still behave like a list tag.
template<$template_params(max_base_list, default=' = vtkm::internal::NullType')>
struct ListTagBase : detail::ListRoot
{
  typedef detail::ListBase<void($param_list(max_base_list))> List;
};

$for(num_params in xrange(0, (max_base_list+1)-1))\
template<$template_params(num_params)>
struct ListTagBase<$param_list(num_params)> : detail::ListRoot
{
  typedef detail::ListBase<void($param_list(num_params))> List;
};

$endfor\

} // namespace vtkm

#endif //vtk_m_internal_ListTagDetail_h
