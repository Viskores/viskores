//=============================================================================
//
//  Copyright (c) Kitware, Inc.
//  All rights reserved.
//  See LICENSE.txt for details.
//
//  This software is distributed WITHOUT ANY WARRANTY; without even
//  the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
//  PURPOSE.  See the above copyright notice for more information.
//
//  Copyright 2015 Sandia Corporation.
//  Copyright 2015 UT-Battelle, LLC.
//  Copyright 2015 Los Alamos National Security.
//
//  Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
//  the U.S. Government retains certain rights in this software.
//  Under the terms of Contract DE-AC52-06NA25396 with Los Alamos National
//  Laboratory (LANL), the U.S. Government retains certain rights in
//  this software.
//
//=============================================================================
$# This file uses the pyexpander macro processing utility to build the
$# FunctionInterface facilities that use a variable number of arguments.
$# Information, documentation, and downloads for pyexpander can be found at:
$#
$#     http://pyexpander.sourceforge.net/
$#
$# To build the source code, execute the following (after installing
$# pyexpander, of course):
$#
$#     expander.py Math.h.in > Math.h
$#
$# Ignore the following comment. It is meant for the generated file.
// **** DO NOT EDIT THIS FILE!!! ****
// This file is automatically generated by FunctionInterfaceDetailPre.h.in

#ifndef vtk_m_Math_h
#define vtk_m_Math_h

#include <vtkm/Types.h>

#ifndef VTKM_CUDA
#include <math.h>
#endif

#if VTKM_MSVC && !defined(VTKM_CUDA)
#include <boost/math/special_functions/cbrt.hpp>
#include <boost/math/special_functions/expm1.hpp>
#include <boost/math/special_functions/log1p.hpp>
#define VTKM_USE_BOOST_MATH
#if _MSC_VER <= 1600
#define VTKM_USE_STL_MIN_MAX
#include <algorithm>
#endif
#endif

#define VTKM_SYS_MATH_FUNCTION_32(func) func ## f
#define VTKM_SYS_MATH_FUNCTION_64(func) func

$py(
def unary_function(name, type, expression):
  return '''VTKM_EXEC_CONT_EXPORT
{1} {0}({1} x) {{
  return {2};
}}
'''.format(name, type, expression)

def unary_Vec_function(vtkmname):
  return '''template<typename T, vtkm::IdComponent N>
VTKM_EXEC_CONT_EXPORT
vtkm::Vec<T,N> {0}(const vtkm::Vec<T,N> &x) {{
  vtkm::Vec<T,N> result;
  for (vtkm::IdComponent index = 0; index < N; index++)
  {{
    result[index] = vtkm::{0}(x[index]);
  }}
  return result;
}}
template<typename T>
VTKM_EXEC_CONT_EXPORT
vtkm::Vec<T,4> {0}(const vtkm::Vec<T,4> &x) {{
  return vtkm::Vec<T,4>(vtkm::{0}(x[0]),
                        vtkm::{0}(x[1]),
                        vtkm::{0}(x[2]),
                        vtkm::{0}(x[3]));
}}
template<typename T>
VTKM_EXEC_CONT_EXPORT
vtkm::Vec<T,3> {0}(const vtkm::Vec<T,3> &x) {{
  return vtkm::Vec<T,3>(vtkm::{0}(x[0]),
                        vtkm::{0}(x[1]),
                        vtkm::{0}(x[2]));
}}
template<typename T>
VTKM_EXEC_CONT_EXPORT
vtkm::Vec<T,2> {0}(const vtkm::Vec<T,2> &x) {{
  return vtkm::Vec<T,2>(vtkm::{0}(x[0]),
                        vtkm::{0}(x[1]));
}}
'''.format(vtkmname)

def unary_math_function_no_vec(vtkmname, sysname):
  return unary_function(vtkmname,
                        'vtkm::Float32',
                        'VTKM_SYS_MATH_FUNCTION_32(' + sysname + ')(x)') + \
         unary_function(vtkmname,
                        'vtkm::Float64',
                        'VTKM_SYS_MATH_FUNCTION_64(' + sysname + ')(x)')

def unary_math_function(vtkmname, sysname):
  return unary_math_function_no_vec(vtkmname, sysname) + \
         unary_Vec_function(vtkmname)

def unary_template_function_no_vec(vtkmname, expression):
  return '''VTKM_EXEC_CONT_EXPORT
vtkm::Float32 {0}(vtkm::Float32 x) {{
  return {1};
}}
VTKM_EXEC_CONT_EXPORT
vtkm::Float64 {0}(vtkm::Float64 x) {{
  return {1};
}}
'''.format(vtkmname, expression)

def binary_function(name, type, expression):
  return '''VTKM_EXEC_CONT_EXPORT
{1} {0}({1} x, {1} y) {{
  return {2};
}}
'''.format(name, type, expression)

def binary_math_function(vtkmname, sysname):
  return binary_function(vtkmname,
                         'vtkm::Float32',
                         'VTKM_SYS_MATH_FUNCTION_32(' + sysname + ')(x,y)') + \
         binary_function(vtkmname,
                         'vtkm::Float64',
                         'VTKM_SYS_MATH_FUNCTION_64(' + sysname + ')(x,y)')

def binary_template_function(vtkmname, expression):
  return '''VTKM_EXEC_CONT_EXPORT
vtkm::Float32 {0}(vtkm::Float32 x, vtkm::Float32 y) {{
  return {1};
}}
VTKM_EXEC_CONT_EXPORT
vtkm::Float64 {0}(vtkm::Float64 x, vtkm::Float64 y) {{
  return {1};
}}
'''.format(vtkmname, expression)
)
$extend(unary_math_function)
$extend(unary_math_function_no_vec)
$extend(unary_Vec_function)
$extend(unary_template_function_no_vec)
$extend(binary_math_function)
$extend(binary_template_function)

namespace vtkm {

/// Computes \p x raised to the power of \p y.
///
$binary_math_function('Pow', 'pow')

/// Compute the square root of \p x.
///
$unary_math_function('Sqrt', 'sqrt')

/// Compute the reciprocal square root of \p x. The result of this function is
/// equivalent to <tt>1/Sqrt(x)</tt>. However, on some devices it is faster to
/// compute the reciprocal square root than the regular square root. Thus, you
/// should use this function whenever dividing by the square root.
///
#ifdef VTKM_CUDA
$unary_math_function_no_vec('RSqrt', 'rsqrt')
#else // !VTKM_CUDA
$unary_template_function_no_vec('RSqrt', '1/vtkm::Sqrt(x)')
#endif // !VTKM_CUDA
$unary_Vec_function('RSqrt')

/// Compute the cube root of \p x.
///
#ifdef VTKM_USE_BOOST_MATH
$unary_template_function_no_vec('Cbrt', 'boost::math::cbrt(x)')
#else // !VTKM_USE_BOOST_MATH
$unary_math_function_no_vec('Cbrt', 'cbrt')
#endif // !VTKM_USE_BOOST_MATH
$unary_Vec_function('Cbrt')

/// Compute the reciprocal cube root of \p x. The result of this function is
/// equivalent to <tt>1/Cbrt(x)</tt>. However, on some devices it is faster to
/// compute the reciprocal cube root than the regular cube root. Thus, you
/// should use this function whenever dividing by the cube root.
///
#ifdef VTKM_CUDA
$unary_math_function_no_vec('RCbrt', 'rcbrt')
#else // !VTKM_CUDA
$unary_template_function_no_vec('RCbrt', '1/vtkm::Cbrt(x)')
#endif // !VTKM_CUDA
$unary_Vec_function('RCbrt')

/// Computes e**\p x, the base-e exponential of \p x.
///
$unary_math_function('Exp', 'exp')

/// Computes 2**\p x, the base-2 exponential of \p x.
///
#ifdef VTKM_MSVC
$unary_template_function_no_vec('Exp2', 'vtkm::Pow(2,x)')
#else // !VTKM_USE_BOOST_MATH
$unary_math_function_no_vec('Exp2', 'exp2')
#endif // !VTKM_USE_BOOST_MATH
$unary_Vec_function('Exp2')

/// Computes (e**\p x) - 1, the of base-e exponental of \p x then minus 1. The
/// accuracy of this function is good even for very small values of x.
///
#ifdef VTKM_USE_BOOST_MATH
$unary_template_function_no_vec('ExpM1', 'boost::math::expm1(x)')
#else // !VTKM_USE_BOOST_MATH
$unary_math_function_no_vec('ExpM1', 'expm1')
#endif // !VTKM_USE_BOOST_MATH
$unary_Vec_function('ExpM1')

/// Computes 10**\p x, the base-10 exponential of \p x.
///
#ifdef VTKM_CUDA
$unary_math_function_no_vec('Exp10', 'exp10')
#else // !VTKM_CUDA
$unary_template_function_no_vec('Exp10', 'vtkm::Pow(10, x);')
#endif // !VTKM_CUDA
$unary_Vec_function('Exp10')

/// Computes the natural logarithm of \p x.
///
$unary_math_function('Log', 'log')

/// Computes the logarithm base 2 of \p x.
///
#ifdef VTKM_MSVC
VTKM_EXEC_CONT_EXPORT
vtkm::Float32 Log2(vtkm::Float32 x) {
  //windows and boost don't provide log2
  //0.6931471805599453 is the constant value of log(2)
  const vtkm::Float32 log2v(0.6931471805599453);
  return vtkm::Log(x)/log2v;
}
VTKM_EXEC_CONT_EXPORT
vtkm::Float64 Log2(vtkm::Float64 x) {
  //windows and boost don't provide log2
  //0.6931471805599453 is the constant value of log(2)
  const vtkm::Float64 log2v(0.6931471805599453);
  return vtkm::Log(x)/log2v;
}
#else // !VTKM_USE_BOOST_MATH
$unary_math_function_no_vec('Log2', 'log2')
#endif // !VTKM_USE_BOOST_MATH
$unary_Vec_function('Log2')

/// Computes the logarithm base 10 of \p x.
///
$unary_math_function('Log10', 'log10')

/// Computes the value of log(1+x) accurately for very small values of x.
///
#ifdef VTKM_USE_BOOST_MATH
$unary_template_function_no_vec('Log1P', 'boost::math::log1p(x)')
#else // !VTKM_USE_BOOST_MATH
$unary_math_function_no_vec('Log1P', 'log1p')
#endif // !VTKM_USE_BOOST_MATH
$unary_Vec_function('Log1P')

//-----------------------------------------------------------------------------
/// Returns \p x or \p y, whichever is larger.
///
template<typename T>
VTKM_EXEC_CONT_EXPORT
T Max(const T &x, const T &y) {
  return (x < y) ? y : x;
}
#ifdef VTKM_USE_STL_MIN_MAX
$binary_template_function('Max', '(std::max)(x, y)')
#else // !VTKM_USE_BOOST_MATH
$binary_math_function('Max', 'fmax')
#endif // !VTKM_USE_BOOST_MATH

/// Returns \p x or \p y, whichever is smaller.
///
template<typename T>
VTKM_EXEC_CONT_EXPORT
T Min(const T &x, const T &y) {
  return (x < y) ? x : y;
}
#ifdef VTKM_USE_STL_MIN_MAX
$binary_template_function('Min', '(std::min)(x, y)')
#else // !VTKM_USE_BOOST_MATH
$binary_math_function('Min', 'fmin')
#endif // !VTKM_USE_BOOST_MATH
} // namespace vtkm

#endif //vtk_m_Math_h
