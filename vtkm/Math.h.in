//=============================================================================
//
//  Copyright (c) Kitware, Inc.
//  All rights reserved.
//  See LICENSE.txt for details.
//
//  This software is distributed WITHOUT ANY WARRANTY; without even
//  the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
//  PURPOSE.  See the above copyright notice for more information.
//
//  Copyright 2015 Sandia Corporation.
//  Copyright 2015 UT-Battelle, LLC.
//  Copyright 2015 Los Alamos National Security.
//
//  Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
//  the U.S. Government retains certain rights in this software.
//  Under the terms of Contract DE-AC52-06NA25396 with Los Alamos National
//  Laboratory (LANL), the U.S. Government retains certain rights in
//  this software.
//
//=============================================================================
$# This file uses the pyexpander macro processing utility to build the
$# FunctionInterface facilities that use a variable number of arguments.
$# Information, documentation, and downloads for pyexpander can be found at:
$#
$#     http://pyexpander.sourceforge.net/
$#
$# To build the source code, execute the following (after installing
$# pyexpander, of course):
$#
$#     expander.py Math.h.in > Math.h
$#
$# Ignore the following comment. It is meant for the generated file.
// **** DO NOT EDIT THIS FILE!!! ****
// This file is automatically generated by FunctionInterfaceDetailPre.h.in

#ifndef vtk_m_Math_h
#define vtk_m_Math_h

#include <vtkm/Types.h>

#ifndef VTKM_CUDA
#include <math.h>
#endif

#define VTKM_SYS_MATH_FUNCTION_32(func) func ## f
#define VTKM_SYS_MATH_FUNCTION_64(func) func

$py(
def unary_function(name, type, expression):
  return '''VTKM_EXEC_CONT_EXPORT
{1} {0}({1} x) {{
  return {2};
}}
'''.format(name, type, expression)

def unary_Vec_function(vtkmname):
  return '''template<typename T, vtkm::IdComponent N>
vtkm::Vec<T,N> {0}(const vtkm::Vec<T,N> x) {{
  vtkm::Vec<T,N> result;
  for (vtkm::IdComponent index = 0; index < N; index++)
  {{
    result[index] = vtkm::{0}(x[index]);
  }}
  return result;
}}
template<typename T>
VTKM_EXEC_CONT_EXPORT
vtkm::Vec<T,4> {0}(const vtkm::Vec<T,4> x) {{
  return vtkm::Vec<T,4>(vtkm::{0}(x[0]),
                        vtkm::{0}(x[1]),
                        vtkm::{0}(x[2]),
                        vtkm::{0}(x[3]));
}}
template<typename T>
VTKM_EXEC_CONT_EXPORT
vtkm::Vec<T,3> {0}(const vtkm::Vec<T,3> x) {{
  return vtkm::Vec<T,3>(vtkm::{0}(x[0]),
                        vtkm::{0}(x[1]),
                        vtkm::{0}(x[2]));
}}
template<typename T>
VTKM_EXEC_CONT_EXPORT
vtkm::Vec<T,2> {0}(const vtkm::Vec<T,2> x) {{
  return vtkm::Vec<T,2>(vtkm::{0}(x[0]),
                        vtkm::{0}(x[1]));
}}
'''.format(vtkmname)

def unary_math_function(vtkmname, sysname):
  return unary_function(vtkmname,
                        'vtkm::Float32',
                        'VTKM_SYS_MATH_FUNCTION_32(' + sysname + ')(x)') + \
         unary_function(vtkmname,
                        'vtkm::Float64',
                        'VTKM_SYS_MATH_FUNCTION_64(' + sysname + ')(x)') + \
         unary_Vec_function(vtkmname)
)
$extend(unary_math_function)

namespace vtkm {

/// Compute the square root of \p x.
///
$unary_math_function('Sqrt', 'sqrt')

} // namespace vtkm

#endif //vtk_m_Math_h
